---
title: Terraform Coding Standards
description: Detailed coding conventions and file organization standards for Terraform Infrastructure as Code in CAIRA.
author: CAIRA Team
ms.date: 08/04/2025
ms.topic: reference
estimated_reading_time: 15
keywords:
    - terraform
    - coding standards
    - conventions
    - infrastructure as code
    - azure
    - CAIRA
    - best practices
    - organization
---

# Terraform Coding Standards

You are an expert in Terraform Infrastructure as Code (IaC) with deep knowledge of Azure resources.

This file contains detailed coding conventions and file organization standards for Terraform.

You MUST ALWAYS meticulously follow these Terraform standards and conventions without deviation.

<!-- <table-of-contents> -->
## Table of Contents

- [Table of Contents](#table-of-contents)
- [Terraform Coding Conventions](#terraform-coding-conventions)
  - [Terraform General Conventions](#terraform-general-conventions)
    - [File and Naming Standards](#file-and-naming-standards)
    - [Documentation and Comments](#documentation-and-comments)
    - [Variables and Parameters](#variables-and-parameters)
    - [Module Structure](#module-structure)
    - [Module Version Management](#module-version-management)
  - [File Organization Standards](#file-organization-standards)
    - [Main File Organization](#main-file-organization)
    - [Variables Organization](#variables-organization)
    - [Outputs Organization](#outputs-organization)
  - [terraform-docs Standards](#terraform-docs-standards)
    - [Autogenerated Documentation](#autogenerated-documentation)
    - [Documentation Markers](#documentation-markers)
<!-- </table-of-contents> -->

## Terraform Coding Conventions

### Terraform General Conventions

<!-- <terraform-general-conventions> -->
#### File and Naming Standards

- You MUST use `kebab-case` for file/folder names, `snake_case` for resources/variables
- You MUST format code via `terraform fmt`
- You MUST NEVER use deprecated properties

#### Documentation and Comments

- You MUST use `#` for single-line or `/* */` for multi-line comments; NEVER use `//`
- You MUST include a markdown comment at the TOP of EVERY `main.tf` file
- You MUST provide descriptive `description` for all variables/outputs, ending with a period
- You MUST add helpful comments for non-obvious code
- You MUST NOT add redundant comments

#### Variables and Parameters

- You MUST specify `type` for all variables
- You MUST start boolean variables with `should_` or `is_`
- You MUST NOT add defaults to required variables
- You MUST include fallback values in descriptions (e.g., "Otherwise, 'id-{resource_prefix}-{environment}-{instance}'.")
- You MUST sort variables alphabetically within functional groupings
- You MUST use `try()`, `coalesce()` instead of ternary operators where possible
- You MUST provide variables for common settings
- You MUST use proper resource references for dependencies
- You MUST NOT use ternary operators unless unavoidable

#### Module Structure

- You MUST use AVM (Azure Verified Modules) standards for the modules folder when available. You can find AVM standards and best practices using the Terraform MCP Server tools to search for verified module patterns and implementations.
  - AVM start with the prefix of **avm** and apply to most of the azure services. Do not default to using the azurerm modules. This is not the correct pattern if the AVM exists.
  - You MUST use the Terraform MCP Server to get the LATEST VERSION of the terraform module.
  - You MUST first use Context7 MCP to resolve the library ID, then use Terraform MCP Server to get the module definition and latest version.
- You MUST NOT create provider blocks in modules
- You MUST NOT modify provider blocks except in `testing/`
- You MUST NOT violate module relationship rules when referencing modules

#### Module Version Management

**CRITICAL**: Always use the latest version of Azure Verified Modules (AVM) to ensure:

- Latest security patches and vulnerability fixes
- New Azure service features and capabilities
- Critical bug fixes and stability improvements
- Azure API compatibility and support

**Version Verification Requirements**:

- You MUST check for the latest AVM version before any module creation or update using Terraform MCP Server tools
- You MUST first use Context7 MCP to resolve the library ID for the Azure service
- You MUST then use Terraform MCP Server to get the latest version and module definition
- You MUST use exact version pinning (e.g., `version = "1.2.3"`) never ranges
- You MUST document the version verification process in module README files
- You MUST include MCP-based version checking examples in module documentation

**Version Checking Methods**:

1. **Terraform MCP Server** (REQUIRED): Use available MCP tools to verify latest versions and module definitions
1. **Terraform Registry**: Check <https://registry.terraform.io/modules/Azure/> for reference only

**Module README Requirements**:

- You MUST include a prominent warning about version management
- You MUST use Terraform MCP Server tools for version verification examples
- You MUST reference this standards document for detailed guidance
- You MUST update documentation when versions change

**Example Version Warning**:

```markdown
## ⚠️ Critical: Always Use Latest AVM Version

This module uses Azure Verified Modules (AVM). Before deployment:

1. **Use Terraform MCP Server**: Use the available MCP tools to get the latest AVM version and module definition

1. **Update Module Version**: Ensure `version = "x.y.z"` reflects the latest release from MCP tools

1. **Review Breaking Changes**: Check release notes for compatibility requirements

- See [Terraform Standards](terraform-standards.md#module-version-management) for complete guidance.

#### Resource Naming

- You MUST follow [Azure naming conventions](https://learn.microsoft.com/azure/cloud-adoption-framework/ready/azure-best-practices/resource-naming)
- You MUST use these patterns:
  - Hyphens allowed: `{resource_abbreviation}-${var.resource_prefix}-{optional_extra}-${var.environment}-${var.instance}`
  - Hyphens not allowed: `{resource_abbreviation}${var.resource_prefix}{optional_extra}${var.environment}${var.instance}`
  - Name length restriction: `'{resource_abbreviation}{optional_extra}${random_string.resource}'`

#### Outputs

- You MUST output resources as objects with necessary fields
- You MUST set `sensitive = true` for secrets
- You MUST provide helpful descriptions
- You MUST use functions like `try()` or `coalesce()`
- You MUST NOT use ternary operators if alternatives exist

#### Architecture-Specific Conventions

For Reference Architectures ONLY (in `/reference_architectures/`):

- You MUST provide defaults for optional variables
- You MUST provide `validation` for variables where conditions are known
- You MUST place resources in `main.tf`
- You MUST NEVER reference another reference architecture directly
- You MUST receive existing resources as objects with only necessary fields
- You MUST reference shared modules using relative paths like `../../modules/module-name`

For Shared Modules ONLY (in `/modules/`):

- You SHOULD provide defaults for variables to improve usability
- You MUST provide `validation` for variables whe3re logical constraints can be enforced
- You MUST place resources in `main.tf`
- You MUST NEVER reference a reference architecture
- You MAY reference other shared modules when there are clear dependencies

#### Enforcing Conventions

You MUST ALWAYS ensure Terraform conventions are followed:

- CONTINUOUSLY evaluate if your changes adhere to these conventions
- Correct any deviations from these conventions
- Suggest convention updates if user changes conflict with conventions
<!-- </terraform-general-conventions> -->

### Reference and Validation

<!-- <reference-validation> -->
- You MUST search the codebase for existing Terraform resources before editing
- If no reference exists:
  1. Use HashiCorp Registry documentation
  1. Check for deprecated fields and use latest properties
  1. Verify provider version requirements
  1. Review common usage examples

- For Azure resources, you MUST choose between `azurerm` and `azapi` providers based on latest capabilities:
  1. **Check azurerm provider first**: Use HashiCorp Registry to verify if the resource exists in the latest azurerm provider version
  1. **Check azapi provider**: If azurerm doesn't support the resource or feature, check azapi provider capabilities
  1. **Compare API versions**: If both providers support the resource, compare the Azure REST API versions:
     - azurerm resources use specific API versions (check provider documentation)
     - azapi resources allow you to specify the latest API version explicitly
  1. **Choose the provider with the latest API version support**
  1. **Preference order**:
     - Latest azurerm resource (if API version is current)
     - azapi resource with latest API version (if azurerm is outdated or missing)

- For `azapi` resources (use when azurerm doesn't exist or has outdated API version):
  1. Use Azure ARM template reference to find the latest API version
  1. Extract resource type for `azapi` with latest API version (e.g., `@2024-02-01`)
  1. Identify required properties for the `body` parameter
  1. Always use the most recent stable API version available
  1. Example:

```terraform
# Check Azure REST API documentation for latest version
# Use azapi when azurerm doesn't support latest features or API version
resource "azapi_resource" "app_service_virtual_network_connection" {
  type      = "Microsoft.Web/sites/virtualNetworkConnections@2024-02-01" # Use latest API version
  name      = "vnet-connection"
  parent_id = var.app_service.id

  body = {
    properties = {
      vnetResourceId = var.virtual_network_subnet.id
      isSwift        = true
      # Include any new properties available in latest API version
    }
  }

  depends_on = [
    var.app_service,
    var.virtual_network_subnet
  ]
}
```

- **Version Verification Process**:
  1. Check HashiCorp Terraform Registry for latest azurerm provider version and resource support
  1. Check Azure REST API documentation for latest API version
  1. Compare capabilities and choose the provider with the most recent API support
  1. Document your choice and reasoning in code comments

- After edits, you MUST:
  1. Run `terraform fmt` and `terraform validate`
  1. Verify VS Code's Terraform diagnostics
  1. Fix all validation issues before committing
<!-- </reference-validation> -->

### File Organization Standards

This section details how to organize content within specific Terraform files.

#### Main File Organization

<!-- <component-main-tf-example> -->
All `main.tf` files MUST follow this organization:

1. Markdown `/** */` comment at the top with title and description
1. Local variables in one `locals` block, grouped by functionality
1. `data` resources, grouped by functionality
1. `resource` resources, grouped by functionality
1. `module` resources, grouped by functionality

Example:

```terraform
/**
 * # AI Foundry Infrastructure
 *
 * Creates core infrastructure components including resource group, storage account,
 * and AI Foundry services for a typical AI application deployment.
 */

locals {
  storage_account_name = "st${var.resource_prefix}${var.environment}${var.instance}"
  project_name         = "${var.resource_prefix}-${var.environment}-${var.instance}"
  tags = merge(var.tags, {
    Environment = var.environment
    Purpose     = "ai_foundry"
  })
}

data "azurerm_client_config" "current" {}

resource "azurerm_resource_group" "main" {
  name     = "rg-${var.resource_prefix}-${var.environment}-${var.instance}"
  location = var.location
  tags     = local.tags
}

resource "azurerm_storage_account" "main" {
  name                     = local.storage_account_name
  resource_group_name      = azurerm_resource_group.main.name
  location                 = azurerm_resource_group.main.location
  account_tier             = "Standard"
  account_replication_type = var.storage_replication_type
  tags                     = local.tags
}

module "ai_foundry" {
  source = "../../modules/ai_foundry"

  location                   = azurerm_resource_group.main.location
  resource_group_resource_id = azurerm_resource_group.main.id
  project_name               = local.project_name
  project_display_name       = "Example AI Project"
  // Additional parameters omitted for brevity
}
```
<!-- </component-main-tf-example> -->

#### Variables Organization

<!-- <component-variables-tf-example> -->
All variables files MUST follow this organization:

1. Required variables (no defaults) grouped at the top
1. Optional variables grouped by functionality
1. Each group with clear comment header
1. Variables alphabetically sorted within groups

Example:

```terraform
/*
 * Core Parameters - Required
 */

variable "environment" {
  type        = string
  description = "Environment for all resources in this module: dev, test, or prod."
}

variable "location" {
  type        = string
  description = "Azure region where all resources will be created."
}

variable "resource_prefix" {
  type        = string
  description = "Prefix for all resources in this module."
}

/*
 * Storage Parameters - Optional
 */

variable "storage_replication_type" {
  type        = string
  description = "Storage account replication type. Otherwise, 'LRS'."
  default     = "LRS"
}

/*
 * Tagging Parameters - Optional
 */

variable "tags" {
  type        = map(string)
  description = "Additional tags to apply to all resources. Otherwise, '{}'."
  default     = {}
}
```
<!-- </component-variables-tf-example> -->

#### Outputs Organization

<!-- <outputs-tf-example> -->
All `outputs.tf` files MUST follow this organization:

1. Outputs grouped by functionality with clear comment headers
1. Outputs sorted alphabetically within each group
1. Consistent field order: `description`, `value`, `sensitive` (if applicable)

Example:

```terraform
/*
 * Resource Group Outputs
 */

output "resource_group" {
  description = "The resource group object with id, name, and location."
  value = {
    id       = azurerm_resource_group.main.id
    name     = azurerm_resource_group.main.name
    location = azurerm_resource_group.main.location
  }
}

/*
 * Storage Outputs
 */

output "storage_account" {
  description = "The storage account object with connection details."
  value = {
    id                 = azurerm_storage_account.main.id
    name               = azurerm_storage_account.main.name
    primary_access_key = azurerm_storage_account.main.primary_access_key
    connection_string  = azurerm_storage_account.main.primary_connection_string
  }
  sensitive = true
}

/*
 * Key Vault Outputs
 */

output "key_vault" {
  description = "The key vault object with access details."
  value       = try(module.key_vault.key_vault, null)
}
```
<!-- </outputs-tf-example> -->

### terraform-docs Standards

You MUST use terraform-docs to automatically generate and maintain documentation for all Terraform modules and reference architectures.

#### Autogenerated Documentation

<!-- <terraform-docs-requirements> -->
**Documentation Sections That MUST Be Autogenerated:**

- Requirements table (Terraform version, provider versions)
- Providers table with version constraints
- Modules table showing external module dependencies
- Resources table listing all created Azure resources
- Inputs table with variable descriptions, types, defaults, and validation
- Outputs table with output descriptions and sensitivity

**Manual Documentation Sections:**

- Module overview and purpose
- Architecture diagrams and explanations
- Usage examples and code samples
- Security considerations and best practices
- Troubleshooting guides and common issues
<!-- </terraform-docs-requirements> -->

#### Documentation Markers

<!-- <terraform-docs-markers> -->
**Required Markers for All Modules:**

```markdown
<!-- BEGIN_TF_DOCS -->
<!-- This content is autogenerated by terraform-docs. Do not edit manually. -->
<!-- END_TF_DOCS -->
```

**Section-Specific Markers (Alternative Pattern):**

```markdown
<!-- BEGINNING OF PRE-COMMIT-TERRAFORM DOCS HOOK -->
<!-- This content is autogenerated. Do not edit manually. -->
<!-- END OF PRE-COMMIT-TERRAFORM DOCS HOOK -->
```

**Marker Placement Rules:**

- You MUST place markers immediately before and after autogenerated content
- You MUST NOT include any manual content between terraform-docs markers
- You MUST use consistent marker format across all modules
- You MUST include explanatory comments within markers

**Complete README.md Structure with Markers:**

```markdown
# Module Name

Module description and overview (MANUAL)

## Features

Feature list and capabilities (MANUAL)

## Usage

Usage examples with HCL code blocks (MANUAL)

## Requirements

<!-- BEGIN_TF_DOCS -->
<!-- Requirements table autogenerated by terraform-docs -->
<!-- END_TF_DOCS -->

## Providers

<!-- BEGIN_TF_DOCS -->
<!-- Providers table autogenerated by terraform-docs -->
<!-- END_TF_DOCS -->

## Modules

<!-- BEGIN_TF_DOCS -->
<!-- External modules table autogenerated by terraform-docs -->
<!-- END_TF_DOCS -->

## Resources

<!-- BEGIN_TF_DOCS -->
<!-- Azure resources table autogenerated by terraform-docs -->
<!-- END_TF_DOCS -->

## Inputs

<!-- BEGIN_TF_DOCS -->
<!-- Variables table autogenerated by terraform-docs -->
<!-- END_TF_DOCS -->

## Outputs

<!-- BEGIN_TF_DOCS -->
<!-- Outputs table autogenerated by terraform-docs -->
<!-- END_TF_DOCS -->

## Security

Security considerations and compliance information (MANUAL)

## Contributing

Contribution guidelines and development workflow (MANUAL)
```
<!-- </terraform-docs-markers> -->
